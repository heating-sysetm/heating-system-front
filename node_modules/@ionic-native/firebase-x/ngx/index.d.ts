import { IonicNativePlugin } from '@ionic-native/core';
import { Observable } from 'rxjs';
import * as ɵngcc0 from '@angular/core';
export interface IChannelOptions {
    /**
     * Channel ID - must be unique per app package
     */
    id: string;
    /**
     * Channel name. Default: empty string
     */
    name?: string;
    /**
     * Channel description. Default: empty string
     */
    description?: string;
    /**
     * The sound to play once a push comes. Default value: 'default'
     * Values allowed:
     * 'default' - plays the default notification sound
     * 'ringtone' - plays the currently set ringtone
     * 'false' - silent; don't play any sound
     * filename - the filename of the sound file located in '/res/raw' without file extension (mysound.mp3 -> mysound)
     */
    sound?: string;
    /**
     * Vibrate on new notification. Default value: true
     * Possible values:
     * Boolean - vibrate or not
     * Array - vibration pattern - e.g. [500, 200, 500] - milliseconds vibrate, milliseconds pause, vibrate, pause, etc.
     */
    vibration?: boolean | number[];
    /**
     * Whether to blink the LED
     */
    light?: boolean;
    /**
     * LED color in ARGB format - this example BLUE color. If set to -1, light color will be default. Default value: -1.
     */
    lightColor?: string;
    /**
     * Importance - integer from 0 to 4. Default value: 4
     * 0 - none - no sound, does not show in the shade
     * 1 - min - no sound, only shows in the shade, below the fold
     * 2 - low - no sound, shows in the shade, and potentially in the status bar
     * 3 - default - shows everywhere, makes noise, but does not visually intrude
     * 4 - high - shows everywhere, makes noise and peeks
     */
    importance?: 0 | 1 | 2 | 3 | 4;
    /**
     * Show badge over app icon when non handled pushes are present. Default value: true
     */
    badge?: boolean;
    /**
     * Show message on locked screen. Default value: 1
     * Possible values (default 1):
     * -1 - secret - Do not reveal any part of the notification on a secure lockscreen.
     * 0 - private - Show the notification on all lockscreens, but conceal sensitive or private information on secure lockscreens.
     * 1 - public - Show the notification in its entirety on all lockscreens.
     */
    visibility?: -1 | 0 | 1;
}
export interface FirebaseUser {
    /**
     * ID token
     */
    idToken?: string;
    /**
     * Provider ID
     */
    providerId?: string;
    /**
     * UID
     */
    uid?: string;
    /**
     * photo url
     */
    photoUrl?: string;
    /**
     * phone number
     */
    phoneNumber?: string;
    /**
     * is email verified
     */
    emailIsVerified?: boolean;
    /**
     * email
     */
    email?: string;
    /**
     * name
     */
    name?: string;
}
/**
 * @name Firebase X
 * @description
 * This plugin brings push notifications, analytics, event tracking, crash reporting and more from Google Firebase to your Cordova project! Android and iOS supported.
 * It is a maintained fork from unmaintained ionic-navite plugin called Firebase.
 *
 * @usage
 * ```typescript
 * import { FirebaseX } from '@ionic-native/firebase-x/ngx';
 *
 *
 * constructor(private firebaseX: FirebaseX) { }
 *
 * ...
 *
 *
 * this.firebaseX.getToken()
 *   .then(token => console.log(`The token is ${token}`)) // save the token server-side and use it to push notifications to this device
 *   .catch(error => console.error('Error getting token', error));
 *
 * this.firebaseX.onMessageReceived()
 *   .subscribe(data => console.log(`User opened a notification ${data}`));
 *
 * this.firebaseX.onTokenRefresh()
 *   .subscribe((token: string) => console.log(`Got a new token ${token}`));
 * ```
 * @interfaces
 * IChannelOptions
 *
 */
export declare class FirebaseX extends IonicNativePlugin {
    /**
     * Get the current FCM token.
     * @return {Promise<null | string>} Note that token will be null if it has not been established yet
     */
    getToken(): Promise<null | string>;
    /**
     * Get the app instance ID (an constant ID which persists as long as the app is not uninstalled/reinstalled)
     * @return {Promise<null | string>} Note that ID will be null if it has not been established yet
     */
    getId(): Promise<null | string>;
    /**
     * Get the current FCM user.
     * @return {Promise<FirebaseUser | string>}
     */
    getCurrentUser(): Promise<FirebaseUser | string>;
    /**
     * Get notified when a token is refreshed.
     * @return {Observable<any>}
     */
    onTokenRefresh(): Observable<any>;
    /**
     * iOS only.
     * Get the APNS token allocated for this app install.
     * @return {Promise<null | string>} Note that token will be null if it has not been established yet
     */
    getAPNSToken(): Promise<null | string>;
    /**
     * iOS only.
     * Registers a handler to call when the APNS token is allocated.
     * This will be called once when remote notifications permission has been granted by the user at runtime.
     * @return {Observable<any>}
     */
    onApnsTokenReceived(): Observable<any>;
    /**
     * Registers a callback function to invoke when:
     * - a notification or data message is received by the app
     * - a system notification is tapped by the user
     * @return {Observable<any>}
     */
    onMessageReceived(): Observable<any>;
    /**
     * Grant permission to receive push notifications (will trigger prompt) and return hasPermission: true. iOS only (Android will always return true).
     * @return {Promise<any>}
     */
    grantPermission(): Promise<any>;
    /**
     * Check permission to receive push notifications and return hasPermission: true. iOS only (Android will always return true).
     * @return {Promise<boolean>}
     */
    hasPermission(): Promise<boolean>;
    /**
     * Unregister from firebase, used to stop receiving push notifications. Call this when you logout user from your app.
     */
    unregister(): Promise<any>;
    /**
     * Set a number on the icon badge. Set 0 to clear the badge
     * @param {number} badgeNumber
     * @return {Promise<any>}
     */
    setBadgeNumber(badgeNumber: number): Promise<any>;
    /**
     * Get icon badge number.
     * @return {Promise<any>}
     */
    getBadgeNumber(): Promise<any>;
    /**
     * Clear all pending notifications from the drawer.
     * @return {Promise<any>}
     */
    clearAllNotifications(): Promise<any>;
    /**
     * Subscribe to a topic. Topic messaging allows you to send a message to multiple devices that have opted in to a particular topic.
     * @param {string} topic
     * @return {Promise<any>}
     */
    subscribe(topic: string): Promise<any>;
    /**
     * Unsubscribe from a topic. This will stop you receiving messages for that topic.
     * @param {string} topic
     * @return {Promise<any>}
     */
    unsubscribe(topic: string): Promise<any>;
    /**
     * Indicates whether autoinit is currently enabled. If so, new FCM tokens will be automatically generated.
     */
    isAutoInitEnabled(): Promise<boolean>;
    /**
     * Sets whether to autoinit new FCM tokens. By default, a new token will be generated as soon as the old one is removed.
     * To prevent a new token being generated, by sure to disable autoinit using setAutoInitEnabled() before calling unregister().
     */
    setAutoInitEnabled(enabled: boolean): Promise<any>;
    /**
     * Android 8+ only. Creates a custom channel to be used by notification messages which have the channel property set in the message payload to the id of the created channel:
     * - for background (system) notifications: android.notification.channel_id
     * - for foreground/data notifications: data.notification_android_channel_id
     *
     * Calling on Android 7 or below or another platform will have no effect.
     * @param {IChannelOptions} channelOptions
     * @return {Promise<any>}
     */
    createChannel(channelOptions: IChannelOptions): Promise<any>;
    /**
     * Android 8+ only. Overrides the properties for the default channel.
     * The default channel is used if no other channel exists or is specified in the notification.
     * Any options not specified will not be overridden. Should be called as soon as possible (on app start) so default notifications will work as expected.
     * Calling on Android 7 or below or another platform will have no effect.
     * @param {IChannelOptions} channelOptions
     * @return {Promise<any>}
     */
    setDefaultChannel(channelOptions: IChannelOptions): Promise<any>;
    /**
     * Android 8+ only. Removes a previously defined channel.
     * Calling on Android 7 or below or another platform will have no effect.
     * @param {string} channelID
     * @return {Promise<any>}
     */
    deleteChannel(channelID: string): Promise<any>;
    /**
     * Android 8+ only. Gets a list of all channels.
     * Calling on Android 7 or below or another platform will have no effect.
     * @return {Promise<any>}
     */
    listChannels(): Promise<any>;
    /**
     * Enable/disable analytics collection (useful for GDPR/privacy settings).
     * @param {boolean} enabled
     * @returns {Promise<any>}
     */
    setAnalyticsCollectionEnabled(enabled: boolean): Promise<any>;
    /**
     * Enable/disable Crashlytics collection.
     * @param {boolean} enabled
     * @returns {Promise<any>}
     */
    setCrashlyticsCollectionEnabled(enabled: boolean): Promise<any>;
    /**
     * Enable/disable performance collection.
     * @param {boolean} enabled
     * @returns {Promise<any>}
     */
    setPerformanceCollectionEnabled(enabled: boolean): Promise<any>;
    /**
     * Log an event using Analytics
     * @param {string} type
     * @param {Object} data
     * @return {Promise<any>}
     */
    logEvent(type: string, data: any): Promise<any>;
    /**
     * Set the name of the current screen in Analytics
     * @param {string} name Screen name
     * @return {Promise<any>}
     */
    setScreenName(name: string): Promise<any>;
    /**
     * Set a user id for use in Analytics
     * @param {string} userId
     * @return {Promise<any>}
     */
    setUserId(userId: string): Promise<any>;
    /**
     * Set a user property for use in Analytics
     * @param {string} name
     * @param {string} value
     * @return {Promise<any>}
     */
    setUserProperty(name: string, value: string): Promise<any>;
    /**
     * Set Crashlytics user identifier.
     * To diagnose an issue, it’s often helpful to know which of your users experienced a given crash.
     * Crashlytics includes a way to anonymously identify users in your crash reports.
     * To add user IDs to your reports, assign each user a unique identifier in the form of an ID number, token, or hashed value.
     *
     * More info https://firebase.google.com/docs/crashlytics/customize-crash-reports?authuser=0#set_user_ids
     * @param {string} userId
     * @returns {Promise<any>}
     */
    setCrashlyticsUserId(userId: string): Promise<any>;
    /**
     * Simulates (causes) a fatal native crash which causes a crash event to be sent to Crashlytics (useful for testing).
     * See the Firebase documentation regarding crash testing.
     * Crashes will appear under Event type = "Crashes" in the Crashlytics console.
     * @return {Promise<any>}
     */
    sendCrash(): Promise<any>;
    /**
     * Sends a crash-related log message that will appear in the Logs section of the next native crash event.
     * Note: if you don't then crash, the message won't be sent! Also logs the message to the native device console.
     * @param {string} message
     * @return {Promise<any>}
     */
    logMessage(message: string): Promise<any>;
    /**
     * Sends a non-fatal error event to Crashlytics. In a Cordova app, you may use this to log unhandled Javascript exceptions, for example.
     * The event will appear under Event type = "Non-fatals" in the Crashlytics console.
     * The error message will appear in the Logs section of the non-fatal error event.
     * Also logs the error message to the native device console.
     * @param {string} error
     * @param {object} (optional) a stack trace generated by stacktrace.js
     * @return {Promise<any>}
     */
    logError(error: string, stackTrace?: object): Promise<any>;
    /**
     * Requests verification of a phone number in order to authenticate a user and sign then into Firebase in your app.
     *
     * NOTE: This will only work on physical devices with a SIM card (not iOS Simulator or Android Emulator)
     *
     * In response to your request, you'll receive a verification ID which you can use in conjunction with the verification code
     * to sign the user in.
     *
     * On iOS and some Android devices, the user will receive and SMS containing the verification code which they must manually enter
     * into your app.
     *
     * Some Android devices support "instant verfication", in which case an SMS will not be send and you will be returned
     * the verification code along with the verification ID. In this case, the user doesn't need to do anything in order for you
     * to sign them in.
     *
     * @param {string} phoneNumber - phone number to verify
     * @param {integer} timeOutDuration - time to wait in seconds before timing out
     * @param {string} fakeVerificationCode - (optional) to test instant verification on Android ,specify a fake verification code to return for whitelisted phone numbers.
     *
     * The success callback will be passed a credential object with the following properties:
     *   instantVerification {boolean} - true if the Android device supports instant verification, in which case the verification code will be included in the credential object. If this is false, the device will be sent an SMS containing the verification code for the user to manually enter into your app. Always false on iOS.
     *   verificationId {string} - the verification ID you'll need to pass along with the verification code to sign the user in. Always returned on both Android & iOS.
     *   code {string} - verification code. Will only be present if instantVerification is true. Always undefined on iOS.
     */
    verifyPhoneNumber(phoneNumber: string, timeOutDuration: number, fakeVerificationCode?: string): Promise<any>;
    /**
     * Signs the user into Firebase with credentials obtained using verifyPhoneNumber().
     * See the Android- and iOS-specific Firebase documentation for more info.
     * @param {object} credential - a credential object returned by the success callback of an authentication method
     */
    signInWithCredential(credential: object): Promise<any>;
    /**
     * Creates a new email/password-based user account. If account creation is successful, user will be automatically signed in.
     * @param email
     * @param password
     */
    createUserWithEmailAndPassword(email: string, password: string): Promise<any>;
    /**
     * Signs in to an email/password-based user account.
     * @param email
     * @param password
     */
    signInUserWithEmailAndPassword(email: string, password: string): Promise<any>;
    /**
     * Signs in user with custom token.
     * @param customToken
     */
    signInUserWithCustomToken(customToken: string): Promise<any>;
    /**
     * Signs in user anonymously.
     */
    signInUserAnonymously(): Promise<any>;
    /**
     * Authenticates the user with a Google account to obtain a credential that can be used to sign the user in/link to an existing user account/reauthenticate the user.
     * @param clientId
     */
    authenticateUserWithGoogle(clientId: string): Promise<any>;
    /**
     * Authenticates the user with an Apple account using Sign In with Apple to obtain a credential that can be used to sign the user in/link to an existing user account/reauthenticate the user.
     * @param locale
     */
    authenticateUserWithApple(locale?: string): Promise<any>;
    /**
     * Links the user account to an existing Firebase user account with credentials obtained using verifyPhoneNumber().
     * See the Android- and iOS-specific Firebase documentation for more info.
     * @param {object} credential - a credential object returned by the success callback of an authentication method
     * @param {function} success - callback function to call on successful sign-in using credentials
     * @param {function} error - callback function which will be passed a {string} error message as an argument
     */
    linkUserWithCredential(credential: object, success: () => void, error: (err: string) => void): Promise<any>;
    /**
     * Reauthenticates the currently signed in user with credentials obtained via an authentication method such as verifyPhoneNumber() or authenticateUserWithGoogle().
     * @param {Object} credential - a credential object returned by the success callback of an authentication method
     * @param {function} success - callback function to call on successful sign-in using credentials
     * @param {function} error - callback function which will be passed a {string} error message as an argument
     */
    reauthenticateWithCredential(credential: any, success: () => void, error: (err: string) => void): Promise<any>;
    /**
     * Checks if there is a current Firebase user signed into the app.
     */
    isUserSignedIn(): Promise<boolean>;
    /**
     * Signs current Firebase user out of the app.
     */
    signOutUser(): Promise<any>;
    /**
     * Updates the display name and/or photo URL of the current Firebase user signed into the app.
     * @param profile
     */
    updateUserProfile(profile: {
        name: string;
        photoUri: string;
    }): Promise<any>;
    /**
     * Updates/sets the email address of the current Firebase user signed into the app.
     * @param email
     */
    updateUserEmail(email: string): Promise<any>;
    /**
     * Sends a verification email to the currently configured email address of the current Firebase user signed into the app.
     * When the user opens the contained link, their email address will have been verified.
     */
    sendUserEmailVerification(): Promise<any>;
    /**
     * Updates/sets the account password for the current Firebase user signed into the app.
     * @param password
     */
    updateUserPassword(password: string): Promise<any>;
    /**
     * Sends a password reset email to the specified user email address.
     * Note: doesn't require the Firebase user to be signed in to the app.
     * @param email
     */
    sendUserPasswordResetEmail(email: string): Promise<any>;
    /**
     * Deletes the account of the current Firebase user signed into the app.
     */
    deleteUser(): Promise<any>;
    /**
     * Registers a Javascript function to invoke when Firebase Authentication state changes between user signed in/signed out.
     * @param {function} fn - callback function to invoke when authentication state changes
     */
    registerAuthStateChangeListener(fn: any): Promise<any>;
    /**
     * Fetch Remote Config parameter values for your app.
     * @param {number} cacheExpirationSeconds specify the cacheExpirationSeconds
     * @return {Promise<any>}
     */
    fetch(cacheExpirationSeconds?: number): Promise<any>;
    /**
     * Activate the Remote Config fetched config.
     * @return {Promise<any>}
     */
    activateFetched(): Promise<any>;
    /**
     * Retrieve a Remote Config value.
     * @param {string} key
     * @return {Promise<any>}
     */
    getValue(key: string): Promise<any>;
    /**
     * Android only. Retrieve a Remote Config byte array.
     * @param {string} key
     * @return {Promise<any>}
     */
    getByteArray(key: string): Promise<any>;
    /**
     * Android only. Get the current state of the FirebaseRemoteConfig singleton object.
     * @return {Promise<any>}
     */
    getInfo(): Promise<any>;
    /**
     * Android only. Change the settings for the FirebaseRemoteConfig object's operations.
     * @param {Object} settings
     * @return {Promise<any>}
     */
    setConfigSettings(settings: any): Promise<any>;
    /**
     * Android only. Set defaults in the Remote Config.
     * @param {Object} settings
     * @return {Promise<any>}
     */
    setDefaults(settings: any): Promise<any>;
    /**
     * Start a trace.
     * @param {string} name
     * @return {Promise<any>}
     */
    startTrace(name: string): Promise<any>;
    /**
     * To count the performance-related events that occur in your app (such as cache hits or retries),
     * add a line of code similar to the following whenever the event occurs,
     * using a string other than retry to name that event if you are counting a different type of event.
     * @param {string} name
     * @return {Promise<any>}
     */
    incrementCounter(name: string): Promise<any>;
    /**
     * Stop the trace.
     * @param {string} name
     * @return {Promise<any>}
     */
    stopTrace(name: string): Promise<any>;
    /**
     * Adds a new document to a Firestore collection, which will be allocated an auto-generated document ID.
     * @param {object} document - document object to add to collection
     * @param {string} collection - name of top-level collection to add document to.
     * @param {function} success - callback function to call on successfully adding the document. Will be passed a {string} argument containing the auto-generated document ID that the document was stored against.
     * @param {function} error - callback function which will be passed a {string} error message as an argument.
     */
    addDocumentToFirestoreCollection(document: object, collection: string, success: (id: string) => void, error: (err: string) => void): Promise<any>;
    /**
     * Sets (adds/replaces) a document with the given ID in a Firestore collection.
     * @param {string} documentId - document ID to use when setting document in the collection.
     * @param {object} document - document object to set in collection.
     * @param {string} collection - name of top-level collection to set document in.
     * @param {function} success - callback function to call on successfully setting the document.
     * @param {function} error - callback function which will be passed a {string} error message as an argument.
     */
    setDocumentInFirestoreCollection(documentId: string, document: object, collection: string, success: () => void, error: (err: string) => void): Promise<any>;
    /**
     * Updates an existing document with the given ID in a Firestore collection. This is a non-destructive update that will only
     * overwrite existing keys in the existing document or add new ones if they don't already exist. If the no document with the
     * specified ID exists in the collection, an error will be raised.
     * @param {string} documentId - document ID of the document to update.
     * @param {object} document - entire document or document fragment to update existing document with.
     * @param {string} collection - name of top-level collection to update document in.
     * @param {function} success - callback function to call on successfully updating the document.
     * @param {function} error - callback function which will be passed a {string} error message as an argument.
     */
    updateDocumentInFirestoreCollection(documentId: string, document: object, collection: string, success: () => void, error: (err: string) => void): Promise<any>;
    /**
     * Deletes an existing document with the given ID in a Firestore collection.
     * - Note: If the no document with the specified ID exists in the collection, the Firebase SDK will still return a successful outcome.
     * @param {string} documentId - document ID of the document to delete.
     * @param {string} collection - name of top-level collection to delete document in.
     * @param {function} success - callback function to call on successfully deleting the document.
     * @param {function} error -  callback function which will be passed a {string} error message as an argument.
     */
    deleteDocumentFromFirestoreCollection(documentId: string, collection: string, success: () => void, error: (err: string) => void): Promise<any>;
    /**
     * Fetches an existing document with the given ID from a Firestore collection.
     * -Note: If the no document with the specified ID exists in the collection, the error callback will be invoked.
     * @param {string} documentId - document ID of the document to fetch.
     * @param {string} collection - name of top-level collection to fetch document from.
     * @param {function} success - callback function to call on successfully fetching the document. Will be passed an {object} contain the document contents.
     * @param {function} error - callback function which will be passed a {string} error message as an argument.
     */
    fetchDocumentInFirestoreCollection(documentId: string, collection: string, success: (doc: any) => void, error: (err: string) => void): Promise<any>;
    /**
     * Fetches all the documents in the specific collection.
     * @param {string} collection - name of top-level collection to fetch.
     * @param {function} success - callback function to call on successfully deleting the document. Will be passed an {object} containing all the documents in the collection,
     * indexed by document ID. If a Firebase collection with that name does not exist or it contains no documents, the object will be empty.
     * @param {function} error - callback function which will be passed a {string} error message as an argument.
     */
    fetchFirestoreCollection(collection: string, success: (docs: any) => void, error: (err: string) => void): Promise<any>;
    static ɵfac: ɵngcc0.ɵɵFactoryDef<FirebaseX, never>;
    static ɵprov: ɵngcc0.ɵɵInjectableDef<FirebaseX>;
}

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguZC50cyIsInNvdXJjZXMiOlsiaW5kZXguZC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgSW9uaWNOYXRpdmVQbHVnaW4gfSBmcm9tICdAaW9uaWMtbmF0aXZlL2NvcmUnO1xuaW1wb3J0IHsgT2JzZXJ2YWJsZSB9IGZyb20gJ3J4anMnO1xuZXhwb3J0IGludGVyZmFjZSBJQ2hhbm5lbE9wdGlvbnMge1xuICAgIC8qKlxuICAgICAqIENoYW5uZWwgSUQgLSBtdXN0IGJlIHVuaXF1ZSBwZXIgYXBwIHBhY2thZ2VcbiAgICAgKi9cbiAgICBpZDogc3RyaW5nO1xuICAgIC8qKlxuICAgICAqIENoYW5uZWwgbmFtZS4gRGVmYXVsdDogZW1wdHkgc3RyaW5nXG4gICAgICovXG4gICAgbmFtZT86IHN0cmluZztcbiAgICAvKipcbiAgICAgKiBDaGFubmVsIGRlc2NyaXB0aW9uLiBEZWZhdWx0OiBlbXB0eSBzdHJpbmdcbiAgICAgKi9cbiAgICBkZXNjcmlwdGlvbj86IHN0cmluZztcbiAgICAvKipcbiAgICAgKiBUaGUgc291bmQgdG8gcGxheSBvbmNlIGEgcHVzaCBjb21lcy4gRGVmYXVsdCB2YWx1ZTogJ2RlZmF1bHQnXG4gICAgICogVmFsdWVzIGFsbG93ZWQ6XG4gICAgICogJ2RlZmF1bHQnIC0gcGxheXMgdGhlIGRlZmF1bHQgbm90aWZpY2F0aW9uIHNvdW5kXG4gICAgICogJ3Jpbmd0b25lJyAtIHBsYXlzIHRoZSBjdXJyZW50bHkgc2V0IHJpbmd0b25lXG4gICAgICogJ2ZhbHNlJyAtIHNpbGVudDsgZG9uJ3QgcGxheSBhbnkgc291bmRcbiAgICAgKiBmaWxlbmFtZSAtIHRoZSBmaWxlbmFtZSBvZiB0aGUgc291bmQgZmlsZSBsb2NhdGVkIGluICcvcmVzL3Jhdycgd2l0aG91dCBmaWxlIGV4dGVuc2lvbiAobXlzb3VuZC5tcDMgLT4gbXlzb3VuZClcbiAgICAgKi9cbiAgICBzb3VuZD86IHN0cmluZztcbiAgICAvKipcbiAgICAgKiBWaWJyYXRlIG9uIG5ldyBub3RpZmljYXRpb24uIERlZmF1bHQgdmFsdWU6IHRydWVcbiAgICAgKiBQb3NzaWJsZSB2YWx1ZXM6XG4gICAgICogQm9vbGVhbiAtIHZpYnJhdGUgb3Igbm90XG4gICAgICogQXJyYXkgLSB2aWJyYXRpb24gcGF0dGVybiAtIGUuZy4gWzUwMCwgMjAwLCA1MDBdIC0gbWlsbGlzZWNvbmRzIHZpYnJhdGUsIG1pbGxpc2Vjb25kcyBwYXVzZSwgdmlicmF0ZSwgcGF1c2UsIGV0Yy5cbiAgICAgKi9cbiAgICB2aWJyYXRpb24/OiBib29sZWFuIHwgbnVtYmVyW107XG4gICAgLyoqXG4gICAgICogV2hldGhlciB0byBibGluayB0aGUgTEVEXG4gICAgICovXG4gICAgbGlnaHQ/OiBib29sZWFuO1xuICAgIC8qKlxuICAgICAqIExFRCBjb2xvciBpbiBBUkdCIGZvcm1hdCAtIHRoaXMgZXhhbXBsZSBCTFVFIGNvbG9yLiBJZiBzZXQgdG8gLTEsIGxpZ2h0IGNvbG9yIHdpbGwgYmUgZGVmYXVsdC4gRGVmYXVsdCB2YWx1ZTogLTEuXG4gICAgICovXG4gICAgbGlnaHRDb2xvcj86IHN0cmluZztcbiAgICAvKipcbiAgICAgKiBJbXBvcnRhbmNlIC0gaW50ZWdlciBmcm9tIDAgdG8gNC4gRGVmYXVsdCB2YWx1ZTogNFxuICAgICAqIDAgLSBub25lIC0gbm8gc291bmQsIGRvZXMgbm90IHNob3cgaW4gdGhlIHNoYWRlXG4gICAgICogMSAtIG1pbiAtIG5vIHNvdW5kLCBvbmx5IHNob3dzIGluIHRoZSBzaGFkZSwgYmVsb3cgdGhlIGZvbGRcbiAgICAgKiAyIC0gbG93IC0gbm8gc291bmQsIHNob3dzIGluIHRoZSBzaGFkZSwgYW5kIHBvdGVudGlhbGx5IGluIHRoZSBzdGF0dXMgYmFyXG4gICAgICogMyAtIGRlZmF1bHQgLSBzaG93cyBldmVyeXdoZXJlLCBtYWtlcyBub2lzZSwgYnV0IGRvZXMgbm90IHZpc3VhbGx5IGludHJ1ZGVcbiAgICAgKiA0IC0gaGlnaCAtIHNob3dzIGV2ZXJ5d2hlcmUsIG1ha2VzIG5vaXNlIGFuZCBwZWVrc1xuICAgICAqL1xuICAgIGltcG9ydGFuY2U/OiAwIHwgMSB8IDIgfCAzIHwgNDtcbiAgICAvKipcbiAgICAgKiBTaG93IGJhZGdlIG92ZXIgYXBwIGljb24gd2hlbiBub24gaGFuZGxlZCBwdXNoZXMgYXJlIHByZXNlbnQuIERlZmF1bHQgdmFsdWU6IHRydWVcbiAgICAgKi9cbiAgICBiYWRnZT86IGJvb2xlYW47XG4gICAgLyoqXG4gICAgICogU2hvdyBtZXNzYWdlIG9uIGxvY2tlZCBzY3JlZW4uIERlZmF1bHQgdmFsdWU6IDFcbiAgICAgKiBQb3NzaWJsZSB2YWx1ZXMgKGRlZmF1bHQgMSk6XG4gICAgICogLTEgLSBzZWNyZXQgLSBEbyBub3QgcmV2ZWFsIGFueSBwYXJ0IG9mIHRoZSBub3RpZmljYXRpb24gb24gYSBzZWN1cmUgbG9ja3NjcmVlbi5cbiAgICAgKiAwIC0gcHJpdmF0ZSAtIFNob3cgdGhlIG5vdGlmaWNhdGlvbiBvbiBhbGwgbG9ja3NjcmVlbnMsIGJ1dCBjb25jZWFsIHNlbnNpdGl2ZSBvciBwcml2YXRlIGluZm9ybWF0aW9uIG9uIHNlY3VyZSBsb2Nrc2NyZWVucy5cbiAgICAgKiAxIC0gcHVibGljIC0gU2hvdyB0aGUgbm90aWZpY2F0aW9uIGluIGl0cyBlbnRpcmV0eSBvbiBhbGwgbG9ja3NjcmVlbnMuXG4gICAgICovXG4gICAgdmlzaWJpbGl0eT86IC0xIHwgMCB8IDE7XG59XG5leHBvcnQgaW50ZXJmYWNlIEZpcmViYXNlVXNlciB7XG4gICAgLyoqXG4gICAgICogSUQgdG9rZW5cbiAgICAgKi9cbiAgICBpZFRva2VuPzogc3RyaW5nO1xuICAgIC8qKlxuICAgICAqIFByb3ZpZGVyIElEXG4gICAgICovXG4gICAgcHJvdmlkZXJJZD86IHN0cmluZztcbiAgICAvKipcbiAgICAgKiBVSURcbiAgICAgKi9cbiAgICB1aWQ/OiBzdHJpbmc7XG4gICAgLyoqXG4gICAgICogcGhvdG8gdXJsXG4gICAgICovXG4gICAgcGhvdG9Vcmw/OiBzdHJpbmc7XG4gICAgLyoqXG4gICAgICogcGhvbmUgbnVtYmVyXG4gICAgICovXG4gICAgcGhvbmVOdW1iZXI/OiBzdHJpbmc7XG4gICAgLyoqXG4gICAgICogaXMgZW1haWwgdmVyaWZpZWRcbiAgICAgKi9cbiAgICBlbWFpbElzVmVyaWZpZWQ/OiBib29sZWFuO1xuICAgIC8qKlxuICAgICAqIGVtYWlsXG4gICAgICovXG4gICAgZW1haWw/OiBzdHJpbmc7XG4gICAgLyoqXG4gICAgICogbmFtZVxuICAgICAqL1xuICAgIG5hbWU/OiBzdHJpbmc7XG59XG4vKipcbiAqIEBuYW1lIEZpcmViYXNlIFhcbiAqIEBkZXNjcmlwdGlvblxuICogVGhpcyBwbHVnaW4gYnJpbmdzIHB1c2ggbm90aWZpY2F0aW9ucywgYW5hbHl0aWNzLCBldmVudCB0cmFja2luZywgY3Jhc2ggcmVwb3J0aW5nIGFuZCBtb3JlIGZyb20gR29vZ2xlIEZpcmViYXNlIHRvIHlvdXIgQ29yZG92YSBwcm9qZWN0ISBBbmRyb2lkIGFuZCBpT1Mgc3VwcG9ydGVkLlxuICogSXQgaXMgYSBtYWludGFpbmVkIGZvcmsgZnJvbSB1bm1haW50YWluZWQgaW9uaWMtbmF2aXRlIHBsdWdpbiBjYWxsZWQgRmlyZWJhc2UuXG4gKlxuICogQHVzYWdlXG4gKiBgYGB0eXBlc2NyaXB0XG4gKiBpbXBvcnQgeyBGaXJlYmFzZVggfSBmcm9tICdAaW9uaWMtbmF0aXZlL2ZpcmViYXNlLXgvbmd4JztcbiAqXG4gKlxuICogY29uc3RydWN0b3IocHJpdmF0ZSBmaXJlYmFzZVg6IEZpcmViYXNlWCkgeyB9XG4gKlxuICogLi4uXG4gKlxuICpcbiAqIHRoaXMuZmlyZWJhc2VYLmdldFRva2VuKClcbiAqICAgLnRoZW4odG9rZW4gPT4gY29uc29sZS5sb2coYFRoZSB0b2tlbiBpcyAke3Rva2VufWApKSAvLyBzYXZlIHRoZSB0b2tlbiBzZXJ2ZXItc2lkZSBhbmQgdXNlIGl0IHRvIHB1c2ggbm90aWZpY2F0aW9ucyB0byB0aGlzIGRldmljZVxuICogICAuY2F0Y2goZXJyb3IgPT4gY29uc29sZS5lcnJvcignRXJyb3IgZ2V0dGluZyB0b2tlbicsIGVycm9yKSk7XG4gKlxuICogdGhpcy5maXJlYmFzZVgub25NZXNzYWdlUmVjZWl2ZWQoKVxuICogICAuc3Vic2NyaWJlKGRhdGEgPT4gY29uc29sZS5sb2coYFVzZXIgb3BlbmVkIGEgbm90aWZpY2F0aW9uICR7ZGF0YX1gKSk7XG4gKlxuICogdGhpcy5maXJlYmFzZVgub25Ub2tlblJlZnJlc2goKVxuICogICAuc3Vic2NyaWJlKCh0b2tlbjogc3RyaW5nKSA9PiBjb25zb2xlLmxvZyhgR290IGEgbmV3IHRva2VuICR7dG9rZW59YCkpO1xuICogYGBgXG4gKiBAaW50ZXJmYWNlc1xuICogSUNoYW5uZWxPcHRpb25zXG4gKlxuICovXG5leHBvcnQgZGVjbGFyZSBjbGFzcyBGaXJlYmFzZVggZXh0ZW5kcyBJb25pY05hdGl2ZVBsdWdpbiB7XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBjdXJyZW50IEZDTSB0b2tlbi5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlPG51bGwgfCBzdHJpbmc+fSBOb3RlIHRoYXQgdG9rZW4gd2lsbCBiZSBudWxsIGlmIGl0IGhhcyBub3QgYmVlbiBlc3RhYmxpc2hlZCB5ZXRcbiAgICAgKi9cbiAgICBnZXRUb2tlbigpOiBQcm9taXNlPG51bGwgfCBzdHJpbmc+O1xuICAgIC8qKlxuICAgICAqIEdldCB0aGUgYXBwIGluc3RhbmNlIElEIChhbiBjb25zdGFudCBJRCB3aGljaCBwZXJzaXN0cyBhcyBsb25nIGFzIHRoZSBhcHAgaXMgbm90IHVuaW5zdGFsbGVkL3JlaW5zdGFsbGVkKVxuICAgICAqIEByZXR1cm4ge1Byb21pc2U8bnVsbCB8IHN0cmluZz59IE5vdGUgdGhhdCBJRCB3aWxsIGJlIG51bGwgaWYgaXQgaGFzIG5vdCBiZWVuIGVzdGFibGlzaGVkIHlldFxuICAgICAqL1xuICAgIGdldElkKCk6IFByb21pc2U8bnVsbCB8IHN0cmluZz47XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBjdXJyZW50IEZDTSB1c2VyLlxuICAgICAqIEByZXR1cm4ge1Byb21pc2U8RmlyZWJhc2VVc2VyIHwgc3RyaW5nPn1cbiAgICAgKi9cbiAgICBnZXRDdXJyZW50VXNlcigpOiBQcm9taXNlPEZpcmViYXNlVXNlciB8IHN0cmluZz47XG4gICAgLyoqXG4gICAgICogR2V0IG5vdGlmaWVkIHdoZW4gYSB0b2tlbiBpcyByZWZyZXNoZWQuXG4gICAgICogQHJldHVybiB7T2JzZXJ2YWJsZTxhbnk+fVxuICAgICAqL1xuICAgIG9uVG9rZW5SZWZyZXNoKCk6IE9ic2VydmFibGU8YW55PjtcbiAgICAvKipcbiAgICAgKiBpT1Mgb25seS5cbiAgICAgKiBHZXQgdGhlIEFQTlMgdG9rZW4gYWxsb2NhdGVkIGZvciB0aGlzIGFwcCBpbnN0YWxsLlxuICAgICAqIEByZXR1cm4ge1Byb21pc2U8bnVsbCB8IHN0cmluZz59IE5vdGUgdGhhdCB0b2tlbiB3aWxsIGJlIG51bGwgaWYgaXQgaGFzIG5vdCBiZWVuIGVzdGFibGlzaGVkIHlldFxuICAgICAqL1xuICAgIGdldEFQTlNUb2tlbigpOiBQcm9taXNlPG51bGwgfCBzdHJpbmc+O1xuICAgIC8qKlxuICAgICAqIGlPUyBvbmx5LlxuICAgICAqIFJlZ2lzdGVycyBhIGhhbmRsZXIgdG8gY2FsbCB3aGVuIHRoZSBBUE5TIHRva2VuIGlzIGFsbG9jYXRlZC5cbiAgICAgKiBUaGlzIHdpbGwgYmUgY2FsbGVkIG9uY2Ugd2hlbiByZW1vdGUgbm90aWZpY2F0aW9ucyBwZXJtaXNzaW9uIGhhcyBiZWVuIGdyYW50ZWQgYnkgdGhlIHVzZXIgYXQgcnVudGltZS5cbiAgICAgKiBAcmV0dXJuIHtPYnNlcnZhYmxlPGFueT59XG4gICAgICovXG4gICAgb25BcG5zVG9rZW5SZWNlaXZlZCgpOiBPYnNlcnZhYmxlPGFueT47XG4gICAgLyoqXG4gICAgICogUmVnaXN0ZXJzIGEgY2FsbGJhY2sgZnVuY3Rpb24gdG8gaW52b2tlIHdoZW46XG4gICAgICogLSBhIG5vdGlmaWNhdGlvbiBvciBkYXRhIG1lc3NhZ2UgaXMgcmVjZWl2ZWQgYnkgdGhlIGFwcFxuICAgICAqIC0gYSBzeXN0ZW0gbm90aWZpY2F0aW9uIGlzIHRhcHBlZCBieSB0aGUgdXNlclxuICAgICAqIEByZXR1cm4ge09ic2VydmFibGU8YW55Pn1cbiAgICAgKi9cbiAgICBvbk1lc3NhZ2VSZWNlaXZlZCgpOiBPYnNlcnZhYmxlPGFueT47XG4gICAgLyoqXG4gICAgICogR3JhbnQgcGVybWlzc2lvbiB0byByZWNlaXZlIHB1c2ggbm90aWZpY2F0aW9ucyAod2lsbCB0cmlnZ2VyIHByb21wdCkgYW5kIHJldHVybiBoYXNQZXJtaXNzaW9uOiB0cnVlLiBpT1Mgb25seSAoQW5kcm9pZCB3aWxsIGFsd2F5cyByZXR1cm4gdHJ1ZSkuXG4gICAgICogQHJldHVybiB7UHJvbWlzZTxhbnk+fVxuICAgICAqL1xuICAgIGdyYW50UGVybWlzc2lvbigpOiBQcm9taXNlPGFueT47XG4gICAgLyoqXG4gICAgICogQ2hlY2sgcGVybWlzc2lvbiB0byByZWNlaXZlIHB1c2ggbm90aWZpY2F0aW9ucyBhbmQgcmV0dXJuIGhhc1Blcm1pc3Npb246IHRydWUuIGlPUyBvbmx5IChBbmRyb2lkIHdpbGwgYWx3YXlzIHJldHVybiB0cnVlKS5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlPGJvb2xlYW4+fVxuICAgICAqL1xuICAgIGhhc1Blcm1pc3Npb24oKTogUHJvbWlzZTxib29sZWFuPjtcbiAgICAvKipcbiAgICAgKiBVbnJlZ2lzdGVyIGZyb20gZmlyZWJhc2UsIHVzZWQgdG8gc3RvcCByZWNlaXZpbmcgcHVzaCBub3RpZmljYXRpb25zLiBDYWxsIHRoaXMgd2hlbiB5b3UgbG9nb3V0IHVzZXIgZnJvbSB5b3VyIGFwcC5cbiAgICAgKi9cbiAgICB1bnJlZ2lzdGVyKCk6IFByb21pc2U8YW55PjtcbiAgICAvKipcbiAgICAgKiBTZXQgYSBudW1iZXIgb24gdGhlIGljb24gYmFkZ2UuIFNldCAwIHRvIGNsZWFyIHRoZSBiYWRnZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBiYWRnZU51bWJlclxuICAgICAqIEByZXR1cm4ge1Byb21pc2U8YW55Pn1cbiAgICAgKi9cbiAgICBzZXRCYWRnZU51bWJlcihiYWRnZU51bWJlcjogbnVtYmVyKTogUHJvbWlzZTxhbnk+O1xuICAgIC8qKlxuICAgICAqIEdldCBpY29uIGJhZGdlIG51bWJlci5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlPGFueT59XG4gICAgICovXG4gICAgZ2V0QmFkZ2VOdW1iZXIoKTogUHJvbWlzZTxhbnk+O1xuICAgIC8qKlxuICAgICAqIENsZWFyIGFsbCBwZW5kaW5nIG5vdGlmaWNhdGlvbnMgZnJvbSB0aGUgZHJhd2VyLlxuICAgICAqIEByZXR1cm4ge1Byb21pc2U8YW55Pn1cbiAgICAgKi9cbiAgICBjbGVhckFsbE5vdGlmaWNhdGlvbnMoKTogUHJvbWlzZTxhbnk+O1xuICAgIC8qKlxuICAgICAqIFN1YnNjcmliZSB0byBhIHRvcGljLiBUb3BpYyBtZXNzYWdpbmcgYWxsb3dzIHlvdSB0byBzZW5kIGEgbWVzc2FnZSB0byBtdWx0aXBsZSBkZXZpY2VzIHRoYXQgaGF2ZSBvcHRlZCBpbiB0byBhIHBhcnRpY3VsYXIgdG9waWMuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRvcGljXG4gICAgICogQHJldHVybiB7UHJvbWlzZTxhbnk+fVxuICAgICAqL1xuICAgIHN1YnNjcmliZSh0b3BpYzogc3RyaW5nKTogUHJvbWlzZTxhbnk+O1xuICAgIC8qKlxuICAgICAqIFVuc3Vic2NyaWJlIGZyb20gYSB0b3BpYy4gVGhpcyB3aWxsIHN0b3AgeW91IHJlY2VpdmluZyBtZXNzYWdlcyBmb3IgdGhhdCB0b3BpYy5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdG9waWNcbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlPGFueT59XG4gICAgICovXG4gICAgdW5zdWJzY3JpYmUodG9waWM6IHN0cmluZyk6IFByb21pc2U8YW55PjtcbiAgICAvKipcbiAgICAgKiBJbmRpY2F0ZXMgd2hldGhlciBhdXRvaW5pdCBpcyBjdXJyZW50bHkgZW5hYmxlZC4gSWYgc28sIG5ldyBGQ00gdG9rZW5zIHdpbGwgYmUgYXV0b21hdGljYWxseSBnZW5lcmF0ZWQuXG4gICAgICovXG4gICAgaXNBdXRvSW5pdEVuYWJsZWQoKTogUHJvbWlzZTxib29sZWFuPjtcbiAgICAvKipcbiAgICAgKiBTZXRzIHdoZXRoZXIgdG8gYXV0b2luaXQgbmV3IEZDTSB0b2tlbnMuIEJ5IGRlZmF1bHQsIGEgbmV3IHRva2VuIHdpbGwgYmUgZ2VuZXJhdGVkIGFzIHNvb24gYXMgdGhlIG9sZCBvbmUgaXMgcmVtb3ZlZC5cbiAgICAgKiBUbyBwcmV2ZW50IGEgbmV3IHRva2VuIGJlaW5nIGdlbmVyYXRlZCwgYnkgc3VyZSB0byBkaXNhYmxlIGF1dG9pbml0IHVzaW5nIHNldEF1dG9Jbml0RW5hYmxlZCgpIGJlZm9yZSBjYWxsaW5nIHVucmVnaXN0ZXIoKS5cbiAgICAgKi9cbiAgICBzZXRBdXRvSW5pdEVuYWJsZWQoZW5hYmxlZDogYm9vbGVhbik6IFByb21pc2U8YW55PjtcbiAgICAvKipcbiAgICAgKiBBbmRyb2lkIDgrIG9ubHkuIENyZWF0ZXMgYSBjdXN0b20gY2hhbm5lbCB0byBiZSB1c2VkIGJ5IG5vdGlmaWNhdGlvbiBtZXNzYWdlcyB3aGljaCBoYXZlIHRoZSBjaGFubmVsIHByb3BlcnR5IHNldCBpbiB0aGUgbWVzc2FnZSBwYXlsb2FkIHRvIHRoZSBpZCBvZiB0aGUgY3JlYXRlZCBjaGFubmVsOlxuICAgICAqIC0gZm9yIGJhY2tncm91bmQgKHN5c3RlbSkgbm90aWZpY2F0aW9uczogYW5kcm9pZC5ub3RpZmljYXRpb24uY2hhbm5lbF9pZFxuICAgICAqIC0gZm9yIGZvcmVncm91bmQvZGF0YSBub3RpZmljYXRpb25zOiBkYXRhLm5vdGlmaWNhdGlvbl9hbmRyb2lkX2NoYW5uZWxfaWRcbiAgICAgKlxuICAgICAqIENhbGxpbmcgb24gQW5kcm9pZCA3IG9yIGJlbG93IG9yIGFub3RoZXIgcGxhdGZvcm0gd2lsbCBoYXZlIG5vIGVmZmVjdC5cbiAgICAgKiBAcGFyYW0ge0lDaGFubmVsT3B0aW9uc30gY2hhbm5lbE9wdGlvbnNcbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlPGFueT59XG4gICAgICovXG4gICAgY3JlYXRlQ2hhbm5lbChjaGFubmVsT3B0aW9uczogSUNoYW5uZWxPcHRpb25zKTogUHJvbWlzZTxhbnk+O1xuICAgIC8qKlxuICAgICAqIEFuZHJvaWQgOCsgb25seS4gT3ZlcnJpZGVzIHRoZSBwcm9wZXJ0aWVzIGZvciB0aGUgZGVmYXVsdCBjaGFubmVsLlxuICAgICAqIFRoZSBkZWZhdWx0IGNoYW5uZWwgaXMgdXNlZCBpZiBubyBvdGhlciBjaGFubmVsIGV4aXN0cyBvciBpcyBzcGVjaWZpZWQgaW4gdGhlIG5vdGlmaWNhdGlvbi5cbiAgICAgKiBBbnkgb3B0aW9ucyBub3Qgc3BlY2lmaWVkIHdpbGwgbm90IGJlIG92ZXJyaWRkZW4uIFNob3VsZCBiZSBjYWxsZWQgYXMgc29vbiBhcyBwb3NzaWJsZSAob24gYXBwIHN0YXJ0KSBzbyBkZWZhdWx0IG5vdGlmaWNhdGlvbnMgd2lsbCB3b3JrIGFzIGV4cGVjdGVkLlxuICAgICAqIENhbGxpbmcgb24gQW5kcm9pZCA3IG9yIGJlbG93IG9yIGFub3RoZXIgcGxhdGZvcm0gd2lsbCBoYXZlIG5vIGVmZmVjdC5cbiAgICAgKiBAcGFyYW0ge0lDaGFubmVsT3B0aW9uc30gY2hhbm5lbE9wdGlvbnNcbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlPGFueT59XG4gICAgICovXG4gICAgc2V0RGVmYXVsdENoYW5uZWwoY2hhbm5lbE9wdGlvbnM6IElDaGFubmVsT3B0aW9ucyk6IFByb21pc2U8YW55PjtcbiAgICAvKipcbiAgICAgKiBBbmRyb2lkIDgrIG9ubHkuIFJlbW92ZXMgYSBwcmV2aW91c2x5IGRlZmluZWQgY2hhbm5lbC5cbiAgICAgKiBDYWxsaW5nIG9uIEFuZHJvaWQgNyBvciBiZWxvdyBvciBhbm90aGVyIHBsYXRmb3JtIHdpbGwgaGF2ZSBubyBlZmZlY3QuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNoYW5uZWxJRFxuICAgICAqIEByZXR1cm4ge1Byb21pc2U8YW55Pn1cbiAgICAgKi9cbiAgICBkZWxldGVDaGFubmVsKGNoYW5uZWxJRDogc3RyaW5nKTogUHJvbWlzZTxhbnk+O1xuICAgIC8qKlxuICAgICAqIEFuZHJvaWQgOCsgb25seS4gR2V0cyBhIGxpc3Qgb2YgYWxsIGNoYW5uZWxzLlxuICAgICAqIENhbGxpbmcgb24gQW5kcm9pZCA3IG9yIGJlbG93IG9yIGFub3RoZXIgcGxhdGZvcm0gd2lsbCBoYXZlIG5vIGVmZmVjdC5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlPGFueT59XG4gICAgICovXG4gICAgbGlzdENoYW5uZWxzKCk6IFByb21pc2U8YW55PjtcbiAgICAvKipcbiAgICAgKiBFbmFibGUvZGlzYWJsZSBhbmFseXRpY3MgY29sbGVjdGlvbiAodXNlZnVsIGZvciBHRFBSL3ByaXZhY3kgc2V0dGluZ3MpLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gZW5hYmxlZFxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPGFueT59XG4gICAgICovXG4gICAgc2V0QW5hbHl0aWNzQ29sbGVjdGlvbkVuYWJsZWQoZW5hYmxlZDogYm9vbGVhbik6IFByb21pc2U8YW55PjtcbiAgICAvKipcbiAgICAgKiBFbmFibGUvZGlzYWJsZSBDcmFzaGx5dGljcyBjb2xsZWN0aW9uLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gZW5hYmxlZFxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPGFueT59XG4gICAgICovXG4gICAgc2V0Q3Jhc2hseXRpY3NDb2xsZWN0aW9uRW5hYmxlZChlbmFibGVkOiBib29sZWFuKTogUHJvbWlzZTxhbnk+O1xuICAgIC8qKlxuICAgICAqIEVuYWJsZS9kaXNhYmxlIHBlcmZvcm1hbmNlIGNvbGxlY3Rpb24uXG4gICAgICogQHBhcmFtIHtib29sZWFufSBlbmFibGVkXG4gICAgICogQHJldHVybnMge1Byb21pc2U8YW55Pn1cbiAgICAgKi9cbiAgICBzZXRQZXJmb3JtYW5jZUNvbGxlY3Rpb25FbmFibGVkKGVuYWJsZWQ6IGJvb2xlYW4pOiBQcm9taXNlPGFueT47XG4gICAgLyoqXG4gICAgICogTG9nIGFuIGV2ZW50IHVzaW5nIEFuYWx5dGljc1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlPGFueT59XG4gICAgICovXG4gICAgbG9nRXZlbnQodHlwZTogc3RyaW5nLCBkYXRhOiBhbnkpOiBQcm9taXNlPGFueT47XG4gICAgLyoqXG4gICAgICogU2V0IHRoZSBuYW1lIG9mIHRoZSBjdXJyZW50IHNjcmVlbiBpbiBBbmFseXRpY3NcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBTY3JlZW4gbmFtZVxuICAgICAqIEByZXR1cm4ge1Byb21pc2U8YW55Pn1cbiAgICAgKi9cbiAgICBzZXRTY3JlZW5OYW1lKG5hbWU6IHN0cmluZyk6IFByb21pc2U8YW55PjtcbiAgICAvKipcbiAgICAgKiBTZXQgYSB1c2VyIGlkIGZvciB1c2UgaW4gQW5hbHl0aWNzXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHVzZXJJZFxuICAgICAqIEByZXR1cm4ge1Byb21pc2U8YW55Pn1cbiAgICAgKi9cbiAgICBzZXRVc2VySWQodXNlcklkOiBzdHJpbmcpOiBQcm9taXNlPGFueT47XG4gICAgLyoqXG4gICAgICogU2V0IGEgdXNlciBwcm9wZXJ0eSBmb3IgdXNlIGluIEFuYWx5dGljc1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlXG4gICAgICogQHJldHVybiB7UHJvbWlzZTxhbnk+fVxuICAgICAqL1xuICAgIHNldFVzZXJQcm9wZXJ0eShuYW1lOiBzdHJpbmcsIHZhbHVlOiBzdHJpbmcpOiBQcm9taXNlPGFueT47XG4gICAgLyoqXG4gICAgICogU2V0IENyYXNobHl0aWNzIHVzZXIgaWRlbnRpZmllci5cbiAgICAgKiBUbyBkaWFnbm9zZSBhbiBpc3N1ZSwgaXTigJlzIG9mdGVuIGhlbHBmdWwgdG8ga25vdyB3aGljaCBvZiB5b3VyIHVzZXJzIGV4cGVyaWVuY2VkIGEgZ2l2ZW4gY3Jhc2guXG4gICAgICogQ3Jhc2hseXRpY3MgaW5jbHVkZXMgYSB3YXkgdG8gYW5vbnltb3VzbHkgaWRlbnRpZnkgdXNlcnMgaW4geW91ciBjcmFzaCByZXBvcnRzLlxuICAgICAqIFRvIGFkZCB1c2VyIElEcyB0byB5b3VyIHJlcG9ydHMsIGFzc2lnbiBlYWNoIHVzZXIgYSB1bmlxdWUgaWRlbnRpZmllciBpbiB0aGUgZm9ybSBvZiBhbiBJRCBudW1iZXIsIHRva2VuLCBvciBoYXNoZWQgdmFsdWUuXG4gICAgICpcbiAgICAgKiBNb3JlIGluZm8gaHR0cHM6Ly9maXJlYmFzZS5nb29nbGUuY29tL2RvY3MvY3Jhc2hseXRpY3MvY3VzdG9taXplLWNyYXNoLXJlcG9ydHM/YXV0aHVzZXI9MCNzZXRfdXNlcl9pZHNcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdXNlcklkXG4gICAgICogQHJldHVybnMge1Byb21pc2U8YW55Pn1cbiAgICAgKi9cbiAgICBzZXRDcmFzaGx5dGljc1VzZXJJZCh1c2VySWQ6IHN0cmluZyk6IFByb21pc2U8YW55PjtcbiAgICAvKipcbiAgICAgKiBTaW11bGF0ZXMgKGNhdXNlcykgYSBmYXRhbCBuYXRpdmUgY3Jhc2ggd2hpY2ggY2F1c2VzIGEgY3Jhc2ggZXZlbnQgdG8gYmUgc2VudCB0byBDcmFzaGx5dGljcyAodXNlZnVsIGZvciB0ZXN0aW5nKS5cbiAgICAgKiBTZWUgdGhlIEZpcmViYXNlIGRvY3VtZW50YXRpb24gcmVnYXJkaW5nIGNyYXNoIHRlc3RpbmcuXG4gICAgICogQ3Jhc2hlcyB3aWxsIGFwcGVhciB1bmRlciBFdmVudCB0eXBlID0gXCJDcmFzaGVzXCIgaW4gdGhlIENyYXNobHl0aWNzIGNvbnNvbGUuXG4gICAgICogQHJldHVybiB7UHJvbWlzZTxhbnk+fVxuICAgICAqL1xuICAgIHNlbmRDcmFzaCgpOiBQcm9taXNlPGFueT47XG4gICAgLyoqXG4gICAgICogU2VuZHMgYSBjcmFzaC1yZWxhdGVkIGxvZyBtZXNzYWdlIHRoYXQgd2lsbCBhcHBlYXIgaW4gdGhlIExvZ3Mgc2VjdGlvbiBvZiB0aGUgbmV4dCBuYXRpdmUgY3Jhc2ggZXZlbnQuXG4gICAgICogTm90ZTogaWYgeW91IGRvbid0IHRoZW4gY3Jhc2gsIHRoZSBtZXNzYWdlIHdvbid0IGJlIHNlbnQhIEFsc28gbG9ncyB0aGUgbWVzc2FnZSB0byB0aGUgbmF0aXZlIGRldmljZSBjb25zb2xlLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBtZXNzYWdlXG4gICAgICogQHJldHVybiB7UHJvbWlzZTxhbnk+fVxuICAgICAqL1xuICAgIGxvZ01lc3NhZ2UobWVzc2FnZTogc3RyaW5nKTogUHJvbWlzZTxhbnk+O1xuICAgIC8qKlxuICAgICAqIFNlbmRzIGEgbm9uLWZhdGFsIGVycm9yIGV2ZW50IHRvIENyYXNobHl0aWNzLiBJbiBhIENvcmRvdmEgYXBwLCB5b3UgbWF5IHVzZSB0aGlzIHRvIGxvZyB1bmhhbmRsZWQgSmF2YXNjcmlwdCBleGNlcHRpb25zLCBmb3IgZXhhbXBsZS5cbiAgICAgKiBUaGUgZXZlbnQgd2lsbCBhcHBlYXIgdW5kZXIgRXZlbnQgdHlwZSA9IFwiTm9uLWZhdGFsc1wiIGluIHRoZSBDcmFzaGx5dGljcyBjb25zb2xlLlxuICAgICAqIFRoZSBlcnJvciBtZXNzYWdlIHdpbGwgYXBwZWFyIGluIHRoZSBMb2dzIHNlY3Rpb24gb2YgdGhlIG5vbi1mYXRhbCBlcnJvciBldmVudC5cbiAgICAgKiBBbHNvIGxvZ3MgdGhlIGVycm9yIG1lc3NhZ2UgdG8gdGhlIG5hdGl2ZSBkZXZpY2UgY29uc29sZS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZXJyb3JcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gKG9wdGlvbmFsKSBhIHN0YWNrIHRyYWNlIGdlbmVyYXRlZCBieSBzdGFja3RyYWNlLmpzXG4gICAgICogQHJldHVybiB7UHJvbWlzZTxhbnk+fVxuICAgICAqL1xuICAgIGxvZ0Vycm9yKGVycm9yOiBzdHJpbmcsIHN0YWNrVHJhY2U/OiBvYmplY3QpOiBQcm9taXNlPGFueT47XG4gICAgLyoqXG4gICAgICogUmVxdWVzdHMgdmVyaWZpY2F0aW9uIG9mIGEgcGhvbmUgbnVtYmVyIGluIG9yZGVyIHRvIGF1dGhlbnRpY2F0ZSBhIHVzZXIgYW5kIHNpZ24gdGhlbiBpbnRvIEZpcmViYXNlIGluIHlvdXIgYXBwLlxuICAgICAqXG4gICAgICogTk9URTogVGhpcyB3aWxsIG9ubHkgd29yayBvbiBwaHlzaWNhbCBkZXZpY2VzIHdpdGggYSBTSU0gY2FyZCAobm90IGlPUyBTaW11bGF0b3Igb3IgQW5kcm9pZCBFbXVsYXRvcilcbiAgICAgKlxuICAgICAqIEluIHJlc3BvbnNlIHRvIHlvdXIgcmVxdWVzdCwgeW91J2xsIHJlY2VpdmUgYSB2ZXJpZmljYXRpb24gSUQgd2hpY2ggeW91IGNhbiB1c2UgaW4gY29uanVuY3Rpb24gd2l0aCB0aGUgdmVyaWZpY2F0aW9uIGNvZGVcbiAgICAgKiB0byBzaWduIHRoZSB1c2VyIGluLlxuICAgICAqXG4gICAgICogT24gaU9TIGFuZCBzb21lIEFuZHJvaWQgZGV2aWNlcywgdGhlIHVzZXIgd2lsbCByZWNlaXZlIGFuZCBTTVMgY29udGFpbmluZyB0aGUgdmVyaWZpY2F0aW9uIGNvZGUgd2hpY2ggdGhleSBtdXN0IG1hbnVhbGx5IGVudGVyXG4gICAgICogaW50byB5b3VyIGFwcC5cbiAgICAgKlxuICAgICAqIFNvbWUgQW5kcm9pZCBkZXZpY2VzIHN1cHBvcnQgXCJpbnN0YW50IHZlcmZpY2F0aW9uXCIsIGluIHdoaWNoIGNhc2UgYW4gU01TIHdpbGwgbm90IGJlIHNlbmQgYW5kIHlvdSB3aWxsIGJlIHJldHVybmVkXG4gICAgICogdGhlIHZlcmlmaWNhdGlvbiBjb2RlIGFsb25nIHdpdGggdGhlIHZlcmlmaWNhdGlvbiBJRC4gSW4gdGhpcyBjYXNlLCB0aGUgdXNlciBkb2Vzbid0IG5lZWQgdG8gZG8gYW55dGhpbmcgaW4gb3JkZXIgZm9yIHlvdVxuICAgICAqIHRvIHNpZ24gdGhlbSBpbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwaG9uZU51bWJlciAtIHBob25lIG51bWJlciB0byB2ZXJpZnlcbiAgICAgKiBAcGFyYW0ge2ludGVnZXJ9IHRpbWVPdXREdXJhdGlvbiAtIHRpbWUgdG8gd2FpdCBpbiBzZWNvbmRzIGJlZm9yZSB0aW1pbmcgb3V0XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGZha2VWZXJpZmljYXRpb25Db2RlIC0gKG9wdGlvbmFsKSB0byB0ZXN0IGluc3RhbnQgdmVyaWZpY2F0aW9uIG9uIEFuZHJvaWQgLHNwZWNpZnkgYSBmYWtlIHZlcmlmaWNhdGlvbiBjb2RlIHRvIHJldHVybiBmb3Igd2hpdGVsaXN0ZWQgcGhvbmUgbnVtYmVycy5cbiAgICAgKlxuICAgICAqIFRoZSBzdWNjZXNzIGNhbGxiYWNrIHdpbGwgYmUgcGFzc2VkIGEgY3JlZGVudGlhbCBvYmplY3Qgd2l0aCB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gICAgICogICBpbnN0YW50VmVyaWZpY2F0aW9uIHtib29sZWFufSAtIHRydWUgaWYgdGhlIEFuZHJvaWQgZGV2aWNlIHN1cHBvcnRzIGluc3RhbnQgdmVyaWZpY2F0aW9uLCBpbiB3aGljaCBjYXNlIHRoZSB2ZXJpZmljYXRpb24gY29kZSB3aWxsIGJlIGluY2x1ZGVkIGluIHRoZSBjcmVkZW50aWFsIG9iamVjdC4gSWYgdGhpcyBpcyBmYWxzZSwgdGhlIGRldmljZSB3aWxsIGJlIHNlbnQgYW4gU01TIGNvbnRhaW5pbmcgdGhlIHZlcmlmaWNhdGlvbiBjb2RlIGZvciB0aGUgdXNlciB0byBtYW51YWxseSBlbnRlciBpbnRvIHlvdXIgYXBwLiBBbHdheXMgZmFsc2Ugb24gaU9TLlxuICAgICAqICAgdmVyaWZpY2F0aW9uSWQge3N0cmluZ30gLSB0aGUgdmVyaWZpY2F0aW9uIElEIHlvdSdsbCBuZWVkIHRvIHBhc3MgYWxvbmcgd2l0aCB0aGUgdmVyaWZpY2F0aW9uIGNvZGUgdG8gc2lnbiB0aGUgdXNlciBpbi4gQWx3YXlzIHJldHVybmVkIG9uIGJvdGggQW5kcm9pZCAmIGlPUy5cbiAgICAgKiAgIGNvZGUge3N0cmluZ30gLSB2ZXJpZmljYXRpb24gY29kZS4gV2lsbCBvbmx5IGJlIHByZXNlbnQgaWYgaW5zdGFudFZlcmlmaWNhdGlvbiBpcyB0cnVlLiBBbHdheXMgdW5kZWZpbmVkIG9uIGlPUy5cbiAgICAgKi9cbiAgICB2ZXJpZnlQaG9uZU51bWJlcihwaG9uZU51bWJlcjogc3RyaW5nLCB0aW1lT3V0RHVyYXRpb246IG51bWJlciwgZmFrZVZlcmlmaWNhdGlvbkNvZGU/OiBzdHJpbmcpOiBQcm9taXNlPGFueT47XG4gICAgLyoqXG4gICAgICogU2lnbnMgdGhlIHVzZXIgaW50byBGaXJlYmFzZSB3aXRoIGNyZWRlbnRpYWxzIG9idGFpbmVkIHVzaW5nIHZlcmlmeVBob25lTnVtYmVyKCkuXG4gICAgICogU2VlIHRoZSBBbmRyb2lkLSBhbmQgaU9TLXNwZWNpZmljIEZpcmViYXNlIGRvY3VtZW50YXRpb24gZm9yIG1vcmUgaW5mby5cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gY3JlZGVudGlhbCAtIGEgY3JlZGVudGlhbCBvYmplY3QgcmV0dXJuZWQgYnkgdGhlIHN1Y2Nlc3MgY2FsbGJhY2sgb2YgYW4gYXV0aGVudGljYXRpb24gbWV0aG9kXG4gICAgICovXG4gICAgc2lnbkluV2l0aENyZWRlbnRpYWwoY3JlZGVudGlhbDogb2JqZWN0KTogUHJvbWlzZTxhbnk+O1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgZW1haWwvcGFzc3dvcmQtYmFzZWQgdXNlciBhY2NvdW50LiBJZiBhY2NvdW50IGNyZWF0aW9uIGlzIHN1Y2Nlc3NmdWwsIHVzZXIgd2lsbCBiZSBhdXRvbWF0aWNhbGx5IHNpZ25lZCBpbi5cbiAgICAgKiBAcGFyYW0gZW1haWxcbiAgICAgKiBAcGFyYW0gcGFzc3dvcmRcbiAgICAgKi9cbiAgICBjcmVhdGVVc2VyV2l0aEVtYWlsQW5kUGFzc3dvcmQoZW1haWw6IHN0cmluZywgcGFzc3dvcmQ6IHN0cmluZyk6IFByb21pc2U8YW55PjtcbiAgICAvKipcbiAgICAgKiBTaWducyBpbiB0byBhbiBlbWFpbC9wYXNzd29yZC1iYXNlZCB1c2VyIGFjY291bnQuXG4gICAgICogQHBhcmFtIGVtYWlsXG4gICAgICogQHBhcmFtIHBhc3N3b3JkXG4gICAgICovXG4gICAgc2lnbkluVXNlcldpdGhFbWFpbEFuZFBhc3N3b3JkKGVtYWlsOiBzdHJpbmcsIHBhc3N3b3JkOiBzdHJpbmcpOiBQcm9taXNlPGFueT47XG4gICAgLyoqXG4gICAgICogU2lnbnMgaW4gdXNlciB3aXRoIGN1c3RvbSB0b2tlbi5cbiAgICAgKiBAcGFyYW0gY3VzdG9tVG9rZW5cbiAgICAgKi9cbiAgICBzaWduSW5Vc2VyV2l0aEN1c3RvbVRva2VuKGN1c3RvbVRva2VuOiBzdHJpbmcpOiBQcm9taXNlPGFueT47XG4gICAgLyoqXG4gICAgICogU2lnbnMgaW4gdXNlciBhbm9ueW1vdXNseS5cbiAgICAgKi9cbiAgICBzaWduSW5Vc2VyQW5vbnltb3VzbHkoKTogUHJvbWlzZTxhbnk+O1xuICAgIC8qKlxuICAgICAqIEF1dGhlbnRpY2F0ZXMgdGhlIHVzZXIgd2l0aCBhIEdvb2dsZSBhY2NvdW50IHRvIG9idGFpbiBhIGNyZWRlbnRpYWwgdGhhdCBjYW4gYmUgdXNlZCB0byBzaWduIHRoZSB1c2VyIGluL2xpbmsgdG8gYW4gZXhpc3RpbmcgdXNlciBhY2NvdW50L3JlYXV0aGVudGljYXRlIHRoZSB1c2VyLlxuICAgICAqIEBwYXJhbSBjbGllbnRJZFxuICAgICAqL1xuICAgIGF1dGhlbnRpY2F0ZVVzZXJXaXRoR29vZ2xlKGNsaWVudElkOiBzdHJpbmcpOiBQcm9taXNlPGFueT47XG4gICAgLyoqXG4gICAgICogQXV0aGVudGljYXRlcyB0aGUgdXNlciB3aXRoIGFuIEFwcGxlIGFjY291bnQgdXNpbmcgU2lnbiBJbiB3aXRoIEFwcGxlIHRvIG9idGFpbiBhIGNyZWRlbnRpYWwgdGhhdCBjYW4gYmUgdXNlZCB0byBzaWduIHRoZSB1c2VyIGluL2xpbmsgdG8gYW4gZXhpc3RpbmcgdXNlciBhY2NvdW50L3JlYXV0aGVudGljYXRlIHRoZSB1c2VyLlxuICAgICAqIEBwYXJhbSBsb2NhbGVcbiAgICAgKi9cbiAgICBhdXRoZW50aWNhdGVVc2VyV2l0aEFwcGxlKGxvY2FsZT86IHN0cmluZyk6IFByb21pc2U8YW55PjtcbiAgICAvKipcbiAgICAgKiBMaW5rcyB0aGUgdXNlciBhY2NvdW50IHRvIGFuIGV4aXN0aW5nIEZpcmViYXNlIHVzZXIgYWNjb3VudCB3aXRoIGNyZWRlbnRpYWxzIG9idGFpbmVkIHVzaW5nIHZlcmlmeVBob25lTnVtYmVyKCkuXG4gICAgICogU2VlIHRoZSBBbmRyb2lkLSBhbmQgaU9TLXNwZWNpZmljIEZpcmViYXNlIGRvY3VtZW50YXRpb24gZm9yIG1vcmUgaW5mby5cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gY3JlZGVudGlhbCAtIGEgY3JlZGVudGlhbCBvYmplY3QgcmV0dXJuZWQgYnkgdGhlIHN1Y2Nlc3MgY2FsbGJhY2sgb2YgYW4gYXV0aGVudGljYXRpb24gbWV0aG9kXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gc3VjY2VzcyAtIGNhbGxiYWNrIGZ1bmN0aW9uIHRvIGNhbGwgb24gc3VjY2Vzc2Z1bCBzaWduLWluIHVzaW5nIGNyZWRlbnRpYWxzXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gZXJyb3IgLSBjYWxsYmFjayBmdW5jdGlvbiB3aGljaCB3aWxsIGJlIHBhc3NlZCBhIHtzdHJpbmd9IGVycm9yIG1lc3NhZ2UgYXMgYW4gYXJndW1lbnRcbiAgICAgKi9cbiAgICBsaW5rVXNlcldpdGhDcmVkZW50aWFsKGNyZWRlbnRpYWw6IG9iamVjdCwgc3VjY2VzczogKCkgPT4gdm9pZCwgZXJyb3I6IChlcnI6IHN0cmluZykgPT4gdm9pZCk6IFByb21pc2U8YW55PjtcbiAgICAvKipcbiAgICAgKiBSZWF1dGhlbnRpY2F0ZXMgdGhlIGN1cnJlbnRseSBzaWduZWQgaW4gdXNlciB3aXRoIGNyZWRlbnRpYWxzIG9idGFpbmVkIHZpYSBhbiBhdXRoZW50aWNhdGlvbiBtZXRob2Qgc3VjaCBhcyB2ZXJpZnlQaG9uZU51bWJlcigpIG9yIGF1dGhlbnRpY2F0ZVVzZXJXaXRoR29vZ2xlKCkuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNyZWRlbnRpYWwgLSBhIGNyZWRlbnRpYWwgb2JqZWN0IHJldHVybmVkIGJ5IHRoZSBzdWNjZXNzIGNhbGxiYWNrIG9mIGFuIGF1dGhlbnRpY2F0aW9uIG1ldGhvZFxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IHN1Y2Nlc3MgLSBjYWxsYmFjayBmdW5jdGlvbiB0byBjYWxsIG9uIHN1Y2Nlc3NmdWwgc2lnbi1pbiB1c2luZyBjcmVkZW50aWFsc1xuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IGVycm9yIC0gY2FsbGJhY2sgZnVuY3Rpb24gd2hpY2ggd2lsbCBiZSBwYXNzZWQgYSB7c3RyaW5nfSBlcnJvciBtZXNzYWdlIGFzIGFuIGFyZ3VtZW50XG4gICAgICovXG4gICAgcmVhdXRoZW50aWNhdGVXaXRoQ3JlZGVudGlhbChjcmVkZW50aWFsOiBhbnksIHN1Y2Nlc3M6ICgpID0+IHZvaWQsIGVycm9yOiAoZXJyOiBzdHJpbmcpID0+IHZvaWQpOiBQcm9taXNlPGFueT47XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIHRoZXJlIGlzIGEgY3VycmVudCBGaXJlYmFzZSB1c2VyIHNpZ25lZCBpbnRvIHRoZSBhcHAuXG4gICAgICovXG4gICAgaXNVc2VyU2lnbmVkSW4oKTogUHJvbWlzZTxib29sZWFuPjtcbiAgICAvKipcbiAgICAgKiBTaWducyBjdXJyZW50IEZpcmViYXNlIHVzZXIgb3V0IG9mIHRoZSBhcHAuXG4gICAgICovXG4gICAgc2lnbk91dFVzZXIoKTogUHJvbWlzZTxhbnk+O1xuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgdGhlIGRpc3BsYXkgbmFtZSBhbmQvb3IgcGhvdG8gVVJMIG9mIHRoZSBjdXJyZW50IEZpcmViYXNlIHVzZXIgc2lnbmVkIGludG8gdGhlIGFwcC5cbiAgICAgKiBAcGFyYW0gcHJvZmlsZVxuICAgICAqL1xuICAgIHVwZGF0ZVVzZXJQcm9maWxlKHByb2ZpbGU6IHtcbiAgICAgICAgbmFtZTogc3RyaW5nO1xuICAgICAgICBwaG90b1VyaTogc3RyaW5nO1xuICAgIH0pOiBQcm9taXNlPGFueT47XG4gICAgLyoqXG4gICAgICogVXBkYXRlcy9zZXRzIHRoZSBlbWFpbCBhZGRyZXNzIG9mIHRoZSBjdXJyZW50IEZpcmViYXNlIHVzZXIgc2lnbmVkIGludG8gdGhlIGFwcC5cbiAgICAgKiBAcGFyYW0gZW1haWxcbiAgICAgKi9cbiAgICB1cGRhdGVVc2VyRW1haWwoZW1haWw6IHN0cmluZyk6IFByb21pc2U8YW55PjtcbiAgICAvKipcbiAgICAgKiBTZW5kcyBhIHZlcmlmaWNhdGlvbiBlbWFpbCB0byB0aGUgY3VycmVudGx5IGNvbmZpZ3VyZWQgZW1haWwgYWRkcmVzcyBvZiB0aGUgY3VycmVudCBGaXJlYmFzZSB1c2VyIHNpZ25lZCBpbnRvIHRoZSBhcHAuXG4gICAgICogV2hlbiB0aGUgdXNlciBvcGVucyB0aGUgY29udGFpbmVkIGxpbmssIHRoZWlyIGVtYWlsIGFkZHJlc3Mgd2lsbCBoYXZlIGJlZW4gdmVyaWZpZWQuXG4gICAgICovXG4gICAgc2VuZFVzZXJFbWFpbFZlcmlmaWNhdGlvbigpOiBQcm9taXNlPGFueT47XG4gICAgLyoqXG4gICAgICogVXBkYXRlcy9zZXRzIHRoZSBhY2NvdW50IHBhc3N3b3JkIGZvciB0aGUgY3VycmVudCBGaXJlYmFzZSB1c2VyIHNpZ25lZCBpbnRvIHRoZSBhcHAuXG4gICAgICogQHBhcmFtIHBhc3N3b3JkXG4gICAgICovXG4gICAgdXBkYXRlVXNlclBhc3N3b3JkKHBhc3N3b3JkOiBzdHJpbmcpOiBQcm9taXNlPGFueT47XG4gICAgLyoqXG4gICAgICogU2VuZHMgYSBwYXNzd29yZCByZXNldCBlbWFpbCB0byB0aGUgc3BlY2lmaWVkIHVzZXIgZW1haWwgYWRkcmVzcy5cbiAgICAgKiBOb3RlOiBkb2Vzbid0IHJlcXVpcmUgdGhlIEZpcmViYXNlIHVzZXIgdG8gYmUgc2lnbmVkIGluIHRvIHRoZSBhcHAuXG4gICAgICogQHBhcmFtIGVtYWlsXG4gICAgICovXG4gICAgc2VuZFVzZXJQYXNzd29yZFJlc2V0RW1haWwoZW1haWw6IHN0cmluZyk6IFByb21pc2U8YW55PjtcbiAgICAvKipcbiAgICAgKiBEZWxldGVzIHRoZSBhY2NvdW50IG9mIHRoZSBjdXJyZW50IEZpcmViYXNlIHVzZXIgc2lnbmVkIGludG8gdGhlIGFwcC5cbiAgICAgKi9cbiAgICBkZWxldGVVc2VyKCk6IFByb21pc2U8YW55PjtcbiAgICAvKipcbiAgICAgKiBSZWdpc3RlcnMgYSBKYXZhc2NyaXB0IGZ1bmN0aW9uIHRvIGludm9rZSB3aGVuIEZpcmViYXNlIEF1dGhlbnRpY2F0aW9uIHN0YXRlIGNoYW5nZXMgYmV0d2VlbiB1c2VyIHNpZ25lZCBpbi9zaWduZWQgb3V0LlxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IGZuIC0gY2FsbGJhY2sgZnVuY3Rpb24gdG8gaW52b2tlIHdoZW4gYXV0aGVudGljYXRpb24gc3RhdGUgY2hhbmdlc1xuICAgICAqL1xuICAgIHJlZ2lzdGVyQXV0aFN0YXRlQ2hhbmdlTGlzdGVuZXIoZm46IGFueSk6IFByb21pc2U8YW55PjtcbiAgICAvKipcbiAgICAgKiBGZXRjaCBSZW1vdGUgQ29uZmlnIHBhcmFtZXRlciB2YWx1ZXMgZm9yIHlvdXIgYXBwLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBjYWNoZUV4cGlyYXRpb25TZWNvbmRzIHNwZWNpZnkgdGhlIGNhY2hlRXhwaXJhdGlvblNlY29uZHNcbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlPGFueT59XG4gICAgICovXG4gICAgZmV0Y2goY2FjaGVFeHBpcmF0aW9uU2Vjb25kcz86IG51bWJlcik6IFByb21pc2U8YW55PjtcbiAgICAvKipcbiAgICAgKiBBY3RpdmF0ZSB0aGUgUmVtb3RlIENvbmZpZyBmZXRjaGVkIGNvbmZpZy5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlPGFueT59XG4gICAgICovXG4gICAgYWN0aXZhdGVGZXRjaGVkKCk6IFByb21pc2U8YW55PjtcbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZSBhIFJlbW90ZSBDb25maWcgdmFsdWUuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleVxuICAgICAqIEByZXR1cm4ge1Byb21pc2U8YW55Pn1cbiAgICAgKi9cbiAgICBnZXRWYWx1ZShrZXk6IHN0cmluZyk6IFByb21pc2U8YW55PjtcbiAgICAvKipcbiAgICAgKiBBbmRyb2lkIG9ubHkuIFJldHJpZXZlIGEgUmVtb3RlIENvbmZpZyBieXRlIGFycmF5LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXlcbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlPGFueT59XG4gICAgICovXG4gICAgZ2V0Qnl0ZUFycmF5KGtleTogc3RyaW5nKTogUHJvbWlzZTxhbnk+O1xuICAgIC8qKlxuICAgICAqIEFuZHJvaWQgb25seS4gR2V0IHRoZSBjdXJyZW50IHN0YXRlIG9mIHRoZSBGaXJlYmFzZVJlbW90ZUNvbmZpZyBzaW5nbGV0b24gb2JqZWN0LlxuICAgICAqIEByZXR1cm4ge1Byb21pc2U8YW55Pn1cbiAgICAgKi9cbiAgICBnZXRJbmZvKCk6IFByb21pc2U8YW55PjtcbiAgICAvKipcbiAgICAgKiBBbmRyb2lkIG9ubHkuIENoYW5nZSB0aGUgc2V0dGluZ3MgZm9yIHRoZSBGaXJlYmFzZVJlbW90ZUNvbmZpZyBvYmplY3QncyBvcGVyYXRpb25zLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzZXR0aW5nc1xuICAgICAqIEByZXR1cm4ge1Byb21pc2U8YW55Pn1cbiAgICAgKi9cbiAgICBzZXRDb25maWdTZXR0aW5ncyhzZXR0aW5nczogYW55KTogUHJvbWlzZTxhbnk+O1xuICAgIC8qKlxuICAgICAqIEFuZHJvaWQgb25seS4gU2V0IGRlZmF1bHRzIGluIHRoZSBSZW1vdGUgQ29uZmlnLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzZXR0aW5nc1xuICAgICAqIEByZXR1cm4ge1Byb21pc2U8YW55Pn1cbiAgICAgKi9cbiAgICBzZXREZWZhdWx0cyhzZXR0aW5nczogYW55KTogUHJvbWlzZTxhbnk+O1xuICAgIC8qKlxuICAgICAqIFN0YXJ0IGEgdHJhY2UuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlPGFueT59XG4gICAgICovXG4gICAgc3RhcnRUcmFjZShuYW1lOiBzdHJpbmcpOiBQcm9taXNlPGFueT47XG4gICAgLyoqXG4gICAgICogVG8gY291bnQgdGhlIHBlcmZvcm1hbmNlLXJlbGF0ZWQgZXZlbnRzIHRoYXQgb2NjdXIgaW4geW91ciBhcHAgKHN1Y2ggYXMgY2FjaGUgaGl0cyBvciByZXRyaWVzKSxcbiAgICAgKiBhZGQgYSBsaW5lIG9mIGNvZGUgc2ltaWxhciB0byB0aGUgZm9sbG93aW5nIHdoZW5ldmVyIHRoZSBldmVudCBvY2N1cnMsXG4gICAgICogdXNpbmcgYSBzdHJpbmcgb3RoZXIgdGhhbiByZXRyeSB0byBuYW1lIHRoYXQgZXZlbnQgaWYgeW91IGFyZSBjb3VudGluZyBhIGRpZmZlcmVudCB0eXBlIG9mIGV2ZW50LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gICAgICogQHJldHVybiB7UHJvbWlzZTxhbnk+fVxuICAgICAqL1xuICAgIGluY3JlbWVudENvdW50ZXIobmFtZTogc3RyaW5nKTogUHJvbWlzZTxhbnk+O1xuICAgIC8qKlxuICAgICAqIFN0b3AgdGhlIHRyYWNlLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gICAgICogQHJldHVybiB7UHJvbWlzZTxhbnk+fVxuICAgICAqL1xuICAgIHN0b3BUcmFjZShuYW1lOiBzdHJpbmcpOiBQcm9taXNlPGFueT47XG4gICAgLyoqXG4gICAgICogQWRkcyBhIG5ldyBkb2N1bWVudCB0byBhIEZpcmVzdG9yZSBjb2xsZWN0aW9uLCB3aGljaCB3aWxsIGJlIGFsbG9jYXRlZCBhbiBhdXRvLWdlbmVyYXRlZCBkb2N1bWVudCBJRC5cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gZG9jdW1lbnQgLSBkb2N1bWVudCBvYmplY3QgdG8gYWRkIHRvIGNvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY29sbGVjdGlvbiAtIG5hbWUgb2YgdG9wLWxldmVsIGNvbGxlY3Rpb24gdG8gYWRkIGRvY3VtZW50IHRvLlxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IHN1Y2Nlc3MgLSBjYWxsYmFjayBmdW5jdGlvbiB0byBjYWxsIG9uIHN1Y2Nlc3NmdWxseSBhZGRpbmcgdGhlIGRvY3VtZW50LiBXaWxsIGJlIHBhc3NlZCBhIHtzdHJpbmd9IGFyZ3VtZW50IGNvbnRhaW5pbmcgdGhlIGF1dG8tZ2VuZXJhdGVkIGRvY3VtZW50IElEIHRoYXQgdGhlIGRvY3VtZW50IHdhcyBzdG9yZWQgYWdhaW5zdC5cbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBlcnJvciAtIGNhbGxiYWNrIGZ1bmN0aW9uIHdoaWNoIHdpbGwgYmUgcGFzc2VkIGEge3N0cmluZ30gZXJyb3IgbWVzc2FnZSBhcyBhbiBhcmd1bWVudC5cbiAgICAgKi9cbiAgICBhZGREb2N1bWVudFRvRmlyZXN0b3JlQ29sbGVjdGlvbihkb2N1bWVudDogb2JqZWN0LCBjb2xsZWN0aW9uOiBzdHJpbmcsIHN1Y2Nlc3M6IChpZDogc3RyaW5nKSA9PiB2b2lkLCBlcnJvcjogKGVycjogc3RyaW5nKSA9PiB2b2lkKTogUHJvbWlzZTxhbnk+O1xuICAgIC8qKlxuICAgICAqIFNldHMgKGFkZHMvcmVwbGFjZXMpIGEgZG9jdW1lbnQgd2l0aCB0aGUgZ2l2ZW4gSUQgaW4gYSBGaXJlc3RvcmUgY29sbGVjdGlvbi5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZG9jdW1lbnRJZCAtIGRvY3VtZW50IElEIHRvIHVzZSB3aGVuIHNldHRpbmcgZG9jdW1lbnQgaW4gdGhlIGNvbGxlY3Rpb24uXG4gICAgICogQHBhcmFtIHtvYmplY3R9IGRvY3VtZW50IC0gZG9jdW1lbnQgb2JqZWN0IHRvIHNldCBpbiBjb2xsZWN0aW9uLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjb2xsZWN0aW9uIC0gbmFtZSBvZiB0b3AtbGV2ZWwgY29sbGVjdGlvbiB0byBzZXQgZG9jdW1lbnQgaW4uXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gc3VjY2VzcyAtIGNhbGxiYWNrIGZ1bmN0aW9uIHRvIGNhbGwgb24gc3VjY2Vzc2Z1bGx5IHNldHRpbmcgdGhlIGRvY3VtZW50LlxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IGVycm9yIC0gY2FsbGJhY2sgZnVuY3Rpb24gd2hpY2ggd2lsbCBiZSBwYXNzZWQgYSB7c3RyaW5nfSBlcnJvciBtZXNzYWdlIGFzIGFuIGFyZ3VtZW50LlxuICAgICAqL1xuICAgIHNldERvY3VtZW50SW5GaXJlc3RvcmVDb2xsZWN0aW9uKGRvY3VtZW50SWQ6IHN0cmluZywgZG9jdW1lbnQ6IG9iamVjdCwgY29sbGVjdGlvbjogc3RyaW5nLCBzdWNjZXNzOiAoKSA9PiB2b2lkLCBlcnJvcjogKGVycjogc3RyaW5nKSA9PiB2b2lkKTogUHJvbWlzZTxhbnk+O1xuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgYW4gZXhpc3RpbmcgZG9jdW1lbnQgd2l0aCB0aGUgZ2l2ZW4gSUQgaW4gYSBGaXJlc3RvcmUgY29sbGVjdGlvbi4gVGhpcyBpcyBhIG5vbi1kZXN0cnVjdGl2ZSB1cGRhdGUgdGhhdCB3aWxsIG9ubHlcbiAgICAgKiBvdmVyd3JpdGUgZXhpc3Rpbmcga2V5cyBpbiB0aGUgZXhpc3RpbmcgZG9jdW1lbnQgb3IgYWRkIG5ldyBvbmVzIGlmIHRoZXkgZG9uJ3QgYWxyZWFkeSBleGlzdC4gSWYgdGhlIG5vIGRvY3VtZW50IHdpdGggdGhlXG4gICAgICogc3BlY2lmaWVkIElEIGV4aXN0cyBpbiB0aGUgY29sbGVjdGlvbiwgYW4gZXJyb3Igd2lsbCBiZSByYWlzZWQuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGRvY3VtZW50SWQgLSBkb2N1bWVudCBJRCBvZiB0aGUgZG9jdW1lbnQgdG8gdXBkYXRlLlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBkb2N1bWVudCAtIGVudGlyZSBkb2N1bWVudCBvciBkb2N1bWVudCBmcmFnbWVudCB0byB1cGRhdGUgZXhpc3RpbmcgZG9jdW1lbnQgd2l0aC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY29sbGVjdGlvbiAtIG5hbWUgb2YgdG9wLWxldmVsIGNvbGxlY3Rpb24gdG8gdXBkYXRlIGRvY3VtZW50IGluLlxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IHN1Y2Nlc3MgLSBjYWxsYmFjayBmdW5jdGlvbiB0byBjYWxsIG9uIHN1Y2Nlc3NmdWxseSB1cGRhdGluZyB0aGUgZG9jdW1lbnQuXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gZXJyb3IgLSBjYWxsYmFjayBmdW5jdGlvbiB3aGljaCB3aWxsIGJlIHBhc3NlZCBhIHtzdHJpbmd9IGVycm9yIG1lc3NhZ2UgYXMgYW4gYXJndW1lbnQuXG4gICAgICovXG4gICAgdXBkYXRlRG9jdW1lbnRJbkZpcmVzdG9yZUNvbGxlY3Rpb24oZG9jdW1lbnRJZDogc3RyaW5nLCBkb2N1bWVudDogb2JqZWN0LCBjb2xsZWN0aW9uOiBzdHJpbmcsIHN1Y2Nlc3M6ICgpID0+IHZvaWQsIGVycm9yOiAoZXJyOiBzdHJpbmcpID0+IHZvaWQpOiBQcm9taXNlPGFueT47XG4gICAgLyoqXG4gICAgICogRGVsZXRlcyBhbiBleGlzdGluZyBkb2N1bWVudCB3aXRoIHRoZSBnaXZlbiBJRCBpbiBhIEZpcmVzdG9yZSBjb2xsZWN0aW9uLlxuICAgICAqIC0gTm90ZTogSWYgdGhlIG5vIGRvY3VtZW50IHdpdGggdGhlIHNwZWNpZmllZCBJRCBleGlzdHMgaW4gdGhlIGNvbGxlY3Rpb24sIHRoZSBGaXJlYmFzZSBTREsgd2lsbCBzdGlsbCByZXR1cm4gYSBzdWNjZXNzZnVsIG91dGNvbWUuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGRvY3VtZW50SWQgLSBkb2N1bWVudCBJRCBvZiB0aGUgZG9jdW1lbnQgdG8gZGVsZXRlLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjb2xsZWN0aW9uIC0gbmFtZSBvZiB0b3AtbGV2ZWwgY29sbGVjdGlvbiB0byBkZWxldGUgZG9jdW1lbnQgaW4uXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gc3VjY2VzcyAtIGNhbGxiYWNrIGZ1bmN0aW9uIHRvIGNhbGwgb24gc3VjY2Vzc2Z1bGx5IGRlbGV0aW5nIHRoZSBkb2N1bWVudC5cbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBlcnJvciAtICBjYWxsYmFjayBmdW5jdGlvbiB3aGljaCB3aWxsIGJlIHBhc3NlZCBhIHtzdHJpbmd9IGVycm9yIG1lc3NhZ2UgYXMgYW4gYXJndW1lbnQuXG4gICAgICovXG4gICAgZGVsZXRlRG9jdW1lbnRGcm9tRmlyZXN0b3JlQ29sbGVjdGlvbihkb2N1bWVudElkOiBzdHJpbmcsIGNvbGxlY3Rpb246IHN0cmluZywgc3VjY2VzczogKCkgPT4gdm9pZCwgZXJyb3I6IChlcnI6IHN0cmluZykgPT4gdm9pZCk6IFByb21pc2U8YW55PjtcbiAgICAvKipcbiAgICAgKiBGZXRjaGVzIGFuIGV4aXN0aW5nIGRvY3VtZW50IHdpdGggdGhlIGdpdmVuIElEIGZyb20gYSBGaXJlc3RvcmUgY29sbGVjdGlvbi5cbiAgICAgKiAtTm90ZTogSWYgdGhlIG5vIGRvY3VtZW50IHdpdGggdGhlIHNwZWNpZmllZCBJRCBleGlzdHMgaW4gdGhlIGNvbGxlY3Rpb24sIHRoZSBlcnJvciBjYWxsYmFjayB3aWxsIGJlIGludm9rZWQuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGRvY3VtZW50SWQgLSBkb2N1bWVudCBJRCBvZiB0aGUgZG9jdW1lbnQgdG8gZmV0Y2guXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNvbGxlY3Rpb24gLSBuYW1lIG9mIHRvcC1sZXZlbCBjb2xsZWN0aW9uIHRvIGZldGNoIGRvY3VtZW50IGZyb20uXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gc3VjY2VzcyAtIGNhbGxiYWNrIGZ1bmN0aW9uIHRvIGNhbGwgb24gc3VjY2Vzc2Z1bGx5IGZldGNoaW5nIHRoZSBkb2N1bWVudC4gV2lsbCBiZSBwYXNzZWQgYW4ge29iamVjdH0gY29udGFpbiB0aGUgZG9jdW1lbnQgY29udGVudHMuXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gZXJyb3IgLSBjYWxsYmFjayBmdW5jdGlvbiB3aGljaCB3aWxsIGJlIHBhc3NlZCBhIHtzdHJpbmd9IGVycm9yIG1lc3NhZ2UgYXMgYW4gYXJndW1lbnQuXG4gICAgICovXG4gICAgZmV0Y2hEb2N1bWVudEluRmlyZXN0b3JlQ29sbGVjdGlvbihkb2N1bWVudElkOiBzdHJpbmcsIGNvbGxlY3Rpb246IHN0cmluZywgc3VjY2VzczogKGRvYzogYW55KSA9PiB2b2lkLCBlcnJvcjogKGVycjogc3RyaW5nKSA9PiB2b2lkKTogUHJvbWlzZTxhbnk+O1xuICAgIC8qKlxuICAgICAqIEZldGNoZXMgYWxsIHRoZSBkb2N1bWVudHMgaW4gdGhlIHNwZWNpZmljIGNvbGxlY3Rpb24uXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNvbGxlY3Rpb24gLSBuYW1lIG9mIHRvcC1sZXZlbCBjb2xsZWN0aW9uIHRvIGZldGNoLlxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IHN1Y2Nlc3MgLSBjYWxsYmFjayBmdW5jdGlvbiB0byBjYWxsIG9uIHN1Y2Nlc3NmdWxseSBkZWxldGluZyB0aGUgZG9jdW1lbnQuIFdpbGwgYmUgcGFzc2VkIGFuIHtvYmplY3R9IGNvbnRhaW5pbmcgYWxsIHRoZSBkb2N1bWVudHMgaW4gdGhlIGNvbGxlY3Rpb24sXG4gICAgICogaW5kZXhlZCBieSBkb2N1bWVudCBJRC4gSWYgYSBGaXJlYmFzZSBjb2xsZWN0aW9uIHdpdGggdGhhdCBuYW1lIGRvZXMgbm90IGV4aXN0IG9yIGl0IGNvbnRhaW5zIG5vIGRvY3VtZW50cywgdGhlIG9iamVjdCB3aWxsIGJlIGVtcHR5LlxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IGVycm9yIC0gY2FsbGJhY2sgZnVuY3Rpb24gd2hpY2ggd2lsbCBiZSBwYXNzZWQgYSB7c3RyaW5nfSBlcnJvciBtZXNzYWdlIGFzIGFuIGFyZ3VtZW50LlxuICAgICAqL1xuICAgIGZldGNoRmlyZXN0b3JlQ29sbGVjdGlvbihjb2xsZWN0aW9uOiBzdHJpbmcsIHN1Y2Nlc3M6IChkb2NzOiBhbnkpID0+IHZvaWQsIGVycm9yOiAoZXJyOiBzdHJpbmcpID0+IHZvaWQpOiBQcm9taXNlPGFueT47XG59XG4iXX0=